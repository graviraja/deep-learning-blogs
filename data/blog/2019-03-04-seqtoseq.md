---
header:
  overlay_color: "#333"
title: "Sequence to Sequence Model"
data: 2019-03-04
tags: [machine learning, data science, deep learning, neural network, sequence to sequence, encoder decoder]
excerpt: "Deep Learning, Sequence to Sequence, Data Science"
mathjax: "true"
---

This post is about the introduction and various building blocks of Sequence to Sequence Model.

As the name suggests, Sequence to Sequence models takes in a sequence and produce another sequence. Sequence can be anything of text/image/audio/video etc.

Generally, all sequence-to-sequence model has encoder, decoder and a intermediate state as main components. Encoder and Decoder can be anytype of rnn/cnn/transformer etc.

![overview fig](/assets/images/seq2seq/overview.png "Overview Figure")

There are many applications which uses sequence to sequence model architecture. Few of them are:
* Language Translation
* Text Summarization
* Chatbots
* Parts of Speech Tagging
* Image Captioning
* Image Modification
* etc..

For better understanding of Sequence to Sequence models, let's take example of Language Translation (English -> German) and see the components.

![arch fig](/assets/images/seq2seq/arch.png "Architecture Figure")

Usually, we use a RNN to encode the source (input) to a context vector. This context vector can be thought as an abstract representation of the entire input sentence. This vector then decoded by the RNN decoder, which learns to output the target (output) sentence by generating one word at a time.

### Encoder

At each time-step, the input to the encoder RNN is both the current word, $$x_t$$, as well as the hidden state from the previous time-step, $$h_{t-1}$$, and the encoder RNN outputs a new hidden state $$h_t$$. You can think of the hidden state as a vector representation of the sentence so far. The RNN can be represented as a function of both of $$x_t$$ and $$h_{t-1}$$:

$$h_t = \text{EncoderRNN}(x_t, h_{t-1})$$

We're using the RNN generally here, it could be any recurrent architecture, such as an *LSTM* (Long Short-Term Memory) or a *GRU* (Gated Recurrent Unit). 

Here, we have $$X = \{x_1, x_2, ..., x_T\}$$, where $$x_1 = \text{Hi}, x_2 = \text{Good}$$, etc. The initial hidden state, $$h_0$$, is usually either initialized to zeros or a learned parameter.

Once the final word, $$x_T$$, has been passed into the RNN, we use the final hidden state, $$h_T$$, as the context vector, i.e. $$h_T = z$$. This is a vector representation of the entire source sentence.


### Decoder

Now we have our context vector, $$z$$, we can start decoding it to get the target sentence, "Hallo Guten Morgen". Again, we append start and end of sequence tokens to the target sentence. At each time-step, the input to the decoder RNN (blue) is the current word, $$y_t$$, as well as the hidden state from the previous time-step, $$s_{t-1}$$, where the initial decoder hidden state, $$s_0$$, is the context vector, $$s_0 = z = h_T$$, i.e. the initial decoder hidden state is the final encoder hidden state. Thus, similar to the encoder, we can represent the decoder as:

$$s_t = \text{DecoderRNN}(y_t, s_{t-1})$$

In the decoder, we need to go from the hidden state to an actual word, therefore at each time-step we use $$s_t$$ to predict (by passing it through a `Linear` layer) what we think is the next word in the sequence, $$\hat{y}_t$$. 

$$\hat{y}_t = f(s_t)$$

We always use `<sos>` for the first input to the decoder, $$y_1$$, but for subsequent inputs, $$y_{t>1}$$, we will sometimes use the actual, ground truth next word in the sequence, $$y_t$$ and sometimes use the word predicted by our decoder, $$\hat{y}_{t-1}$$. This is called *teacher forcing*, and you can read about it more [here](https://machinelearningmastery.com/teacher-forcing-for-recurrent-neural-networks/).

When training/testing our model, we always know how many words are in our target sentence, so we stop generating words once we hit that many. During inference (i.e. real world usage) it is common to keep generating words until the model outputs an `<eos>` token or after a certain amount of words have been generated.

Once we have our predicted target sentence, $$\hat{Y} = \{ \hat{y}_1, \hat{y}_2, ..., \hat{y}_T \}$$, we compare it against our actual target sentence, $$Y = \{ y_1, y_2, ..., y_T \}$$, to calculate our loss. We then use this loss to update all of the parameters in our model.


### References

[Understanding LSTM](https://colah.github.io/posts/2015-08-Understanding-LSTMs/)

[Sequence to Sequence Learning Paper](https://arxiv.org/pdf/1409.3215.pdf)


In the next post, we will see how to implement the language translation in pytorch.

### THANK YOU !!!
{: style="color:black; font-size: 100%; text-align: center;"}